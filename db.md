# Database Schema

PostgreSQL schema for Cosmo conversation storage and artifacts.

## Tables

### `conversation`

Stores full conversation transcripts, metadata, and embeddings for semantic search.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `transcript` | JSON | Full conversation transcript (generated by agent) |
| `abbreviated_transcript` | JSON | Condensed version for quick review |
| `summary` | TEXT | Text summary of conversation |
| `status` | VARCHAR | Conversation status (active, completed, etc.) |
| `created_at` | TIMESTAMP | When conversation started |
| `ended_at` | TIMESTAMP | When conversation ended |
| `trigger_method` | VARCHAR | How conversation was initiated (notification, manual, etc.) |
| `embedding` | VECTOR | Embedding for semantic search |
| `entities_extracted` | BOOLEAN | Whether entities have been extracted to Neo4j |
| `neo4j_synced_at` | TIMESTAMP | Last sync timestamp to Neo4j graph |

**Purpose**: Time-series record of all conversations with full transcript data. Enables semantic search via embeddings and tracks sync status with Neo4j knowledge graph.

---

### `artifact`

Stores synthesized outputs created from conversations (blog posts, plans, technical docs, etc.).

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `conversation_id` | UUID | Foreign key to `conversation.id` |
| `type` | VARCHAR(50) | Artifact type (blog_post, plan, technical_doc, decision_framework, etc.) |
| `title` | TEXT | Artifact title |
| `content` | TEXT | Full artifact content |
| `created_at` | TIMESTAMP | When artifact was created |
| `neo4j_node_id` | VARCHAR(100) | Link to corresponding Artifact node in Neo4j |

**Purpose**: Stores productive outputs from conversations. Links back to source conversation and syncs to Neo4j for relationship tracking.

**Relationships**:
- `artifact.conversation_id` → `conversation.id` (many-to-one)

---

### `user_preference`

Stores learned preferences about how to converse with the user. Loaded entirely into system prompt.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `type` | VARCHAR(50) | Preference type (question_style, topic_to_avoid, conversation_preference) |
| `instruction` | TEXT | The actual preference as a string (e.g., "Don't ask obvious questions about work - user finds it patronizing") |
| `confidence` | FLOAT | Confidence in this preference (0-1, increases with evidence) |
| `strength` | FLOAT | How strongly to enforce (0-1: 0=gentle suggestion, 1=hard rule) |
| `created_at` | TIMESTAMP | When preference was learned |
| `updated_at` | TIMESTAMP | Last time preference was reinforced or adjusted |

**Purpose**: User-specific conversation preferences. Always loaded in full into agent's system prompt.

**Examples**:
- `type: "question_style"`, `instruction: "User loves 'What did you learn from X?' style questions"`, `confidence: 0.9`, `strength: 0.7`
- `type: "topic_to_avoid"`, `instruction: "Never ask generic questions about meditation - user snapped at this"`, `confidence: 1.0`, `strength: 1.0`
- `type: "conversation_preference"`, `instruction: "User prefers brief responses when discussing technical topics"`, `confidence: 0.6`, `strength: 0.5`

---

## Architecture Notes

**PostgreSQL (Relational)**:
- Full transcript storage (JSON)
- Vector embeddings for semantic search
- Time-series conversation records
- Artifact storage
- User conversation preferences (loaded into agent system prompt)

**Neo4j (Graph)** - See `neo4j.md`:
- Entity extraction (people, projects, topics, ideas)
- Relationship mapping
- Pattern detection
- Context retrieval

**Sync Flow**:
1. Conversation completes → saved to PostgreSQL
2. Entity extraction runs → creates/updates Neo4j nodes
3. `entities_extracted` and `neo4j_synced_at` updated
4. Artifacts created → saved to PostgreSQL + linked in Neo4j
