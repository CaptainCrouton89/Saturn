/**
 * LoCoMo10 Answer Scoring Script
 *
 * Scores answers generated by run-locomo10-eval.ts using LLM-as-judge
 *
 * Usage:
 *   pnpm tsx scripts/evaluation/score-locomo10-eval.ts <answers-file.json>
 *   pnpm tsx scripts/evaluation/score-locomo10-eval.ts <answers-file.json> --concurrency 10
 *
 * Examples:
 *   pnpm tsx scripts/evaluation/score-locomo10-eval.ts output/locomo10-eval/answers-conv-26-2025-11-19.json
 */

import 'dotenv/config';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { compareAnswers } from './answer-comparison.js';
import type { LoCoMo10EvalReport } from './types.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Process an array in batches with Promise.all
 */
async function processBatch<T, R>(
  items: T[],
  batchSize: number,
  processor: (item: T, index: number) => Promise<R>
): Promise<R[]> {
  const results: R[] = [];
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchResults = await Promise.all(batch.map((item, batchIndex) => processor(item, i + batchIndex)));
    results.push(...batchResults);
  }
  return results;
}

/**
 * Score answers from an evaluation report
 */
async function scoreAnswers(answersFilePath: string, concurrency: number = 5): Promise<void> {
  console.log('ğŸ¯ LoCoMo10 Answer Scoring\n');
  console.log(`Input file: ${answersFilePath}`);
  console.log(`Concurrency: ${concurrency} parallel scorings\n`);

  // Step 1: Read answers file
  const fileContent = await fs.readFile(answersFilePath, 'utf-8');
  const report: LoCoMo10EvalReport = JSON.parse(fileContent);

  if (report.scored) {
    console.log('âš ï¸  Warning: This report has already been scored!');
    console.log('   Proceeding will re-score all answers.\n');
  }

  console.log(`ğŸ“Š Report info:`);
  console.log(`   Conversation: ${report.sample_id}`);
  console.log(`   Questions: ${report.total_questions}`);
  console.log(`   Sessions: ${report.total_sessions}\n`);

  // Step 2: Score each answer in parallel
  console.log(`ğŸ” Scoring ${report.results.length} answers...\n`);

  const startTime = Date.now();
  let completedCount = 0;

  const scoredResults = await processBatch(report.results, concurrency, async (result, i) => {
    const categoryName =
      result.category === 1 ? 'factual' : result.category === 2 ? 'temporal' : result.category === 3 ? 'reasoning' : 'other';

    try {
      // Skip scoring if answer is an error
      if (result.our_answer.startsWith('ERROR:')) {
        console.log(`[${i + 1}/${report.results.length}] ${categoryName} - Skipping (error answer)`);
        completedCount++;
        return {
          ...result,
          score: 0,
          reasoning: 'Answer generation failed',
        };
      }

      // Score the answer using LLM-as-judge
      const { score, reasoning } = await compareAnswers(result.question, result.expected_answer, result.our_answer);

      completedCount++;
      console.log(
        `[${completedCount}/${report.results.length}] ${categoryName} - Score: ${(score * 100).toFixed(0)}%`
      );

      return {
        ...result,
        score,
        reasoning,
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      console.error(`[${i + 1}/${report.results.length}] ${categoryName} - âŒ Scoring failed: ${errorMsg}`);

      return {
        ...result,
        score: 0,
        reasoning: `Scoring failed: ${errorMsg}`,
      };
    }
  });

  const scoringTimeMs = Date.now() - startTime;

  // Step 3: Calculate aggregate statistics
  const avgScore = scoredResults.reduce((sum, r) => sum + (r.score ?? 0), 0) / scoredResults.length;

  const factualResults = scoredResults.filter(r => r.category === 1);
  const temporalResults = scoredResults.filter(r => r.category === 2);
  const reasoningResults = scoredResults.filter(r => r.category === 3);
  const otherResults = scoredResults.filter(r => r.category === 4);

  const categoryScores = {
    factual:
      factualResults.length > 0
        ? factualResults.reduce((sum, r) => sum + (r.score ?? 0), 0) / factualResults.length
        : 0,
    temporal:
      temporalResults.length > 0
        ? temporalResults.reduce((sum, r) => sum + (r.score ?? 0), 0) / temporalResults.length
        : 0,
    reasoning:
      reasoningResults.length > 0
        ? reasoningResults.reduce((sum, r) => sum + (r.score ?? 0), 0) / reasoningResults.length
        : 0,
    other: otherResults.length > 0 ? otherResults.reduce((sum, r) => sum + (r.score ?? 0), 0) / otherResults.length : 0,
  };

  // Step 4: Update report with scores
  const scoredReport: LoCoMo10EvalReport = {
    ...report,
    results: scoredResults,
    scored: true,
    avg_score: avgScore,
    category_scores: categoryScores,
  };

  // Step 5: Save scored report
  const inputDir = path.dirname(answersFilePath);
  const inputBasename = path.basename(answersFilePath);
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');

  // Generate output filename
  let outputFilename: string;
  if (inputBasename.startsWith('answers-')) {
    // Replace 'answers-' with 'scored-'
    outputFilename = inputBasename.replace(/^answers-/, 'scored-');
  } else if (inputBasename.startsWith('eval-')) {
    // Legacy format - replace 'eval-' with 'scored-'
    outputFilename = inputBasename.replace(/^eval-/, 'scored-');
  } else {
    // Unknown format - add 'scored-' prefix
    outputFilename = `scored-${inputBasename}`;
  }

  const outputPath = path.join(inputDir, outputFilename);
  await fs.writeFile(outputPath, JSON.stringify(scoredReport, null, 2));

  // Step 6: Print summary
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸ“Š SCORING COMPLETE');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log(`Conversation: ${report.sample_id}`);
  console.log(`Questions scored: ${scoredResults.length}`);
  console.log(`Scoring time: ${(scoringTimeMs / 1000).toFixed(2)}s`);
  console.log(`Concurrency: ${concurrency} parallel scorings`);
  console.log('');
  console.log('Overall Performance:');
  console.log(`  Average Score: ${(avgScore * 100).toFixed(1)}%`);
  console.log(`  Average Answer Latency: ${report.avg_latency_ms.toFixed(0)}ms`);
  console.log('');
  console.log('Category Scores:');
  console.log(`  Factual (${factualResults.length} questions): ${(categoryScores.factual * 100).toFixed(1)}%`);
  console.log(`  Temporal (${temporalResults.length} questions): ${(categoryScores.temporal * 100).toFixed(1)}%`);
  console.log(`  Reasoning (${reasoningResults.length} questions): ${(categoryScores.reasoning * 100).toFixed(1)}%`);
  if (otherResults.length > 0) {
    console.log(`  Other (${otherResults.length} questions): ${(categoryScores.other * 100).toFixed(1)}%`);
  }
  console.log('');
  console.log(`ğŸ’¾ Scored report saved: ${outputPath}`);
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
}

// CLI Entry Point
if (import.meta.url === `file://${process.argv[1]}`) {
  const answersFilePath = process.argv[2];

  if (!answersFilePath) {
    console.error('Error: Missing required argument: <answers-file.json>');
    console.error('');
    console.error('Usage:');
    console.error('  pnpm tsx scripts/evaluation/score-locomo10-eval.ts <answers-file.json>');
    console.error('  pnpm tsx scripts/evaluation/score-locomo10-eval.ts <answers-file.json> --concurrency 10');
    process.exit(1);
  }

  // Parse optional --concurrency flag
  let concurrency = 5; // Default
  for (let i = 3; i < process.argv.length; i++) {
    if (process.argv[i] === '--concurrency' && process.argv[i + 1]) {
      concurrency = parseInt(process.argv[i + 1], 10);
      if (isNaN(concurrency)) {
        console.error('Error: --concurrency must be a number');
        process.exit(1);
      }
      break;
    }
  }

  scoreAnswers(answersFilePath, concurrency)
    .then(() => process.exit(0))
    .catch(error => {
      console.error('\nâŒ Fatal error:', error);
      process.exit(1);
    });
}

export { scoreAnswers };
